# Phase 4 - 敌人系统与存档系统设计文档

**日期**: 2026-02-14
**状态**: 设计阶段
**范围**: 基础敌人系统 + 标准存档系统

---

## 1. 概述

Phase 4 实现敌对生物和游戏存档功能，为地下探险游戏提供挑战目标和进度持久化。

### 1.1 核心目标

- **敌人系统**: 实现三种基础敌人（史莱姆、蝙蝠、骷髅）和差异化 AI 行为
- **存档系统**: 基于 IndexedDB 的自动保存和手动保存，保护玩家进度
- **战斗扩展**: 扩展现有战斗系统支持敌人交互

### 1.2 设计原则

- **YAGNI**: Boss 和隐藏区域延后，专注基础体验
- **平衡性**: 不同敌人有不同定位，避免数值膨胀
- **可扩展**: 架构支持未来添加更多敌人和存档类型

---

## 2. 系统架构

### 2.1 新增模块

```
src/
├── enemies/
│   ├── Enemy.ts           # 敌人基类
│   ├── Slime.ts           # 史莱姆实现
│   ├── Bat.ts             # 蝙蝠实现
│   ├── Skeleton.ts        # 骷髅实现
│   ├── EnemyAI.ts          # AI 行为接口
│   └── EnemySpawner.ts    # 刷新控制器
├── save/
│   ├── SaveManager.ts      # IndexedDB 管理
│   ├── SaveData.ts        # 数据结构定义
│   └── AutoSave.ts        # 自动保存定时器
└── entities/
    └── EntityType.ts      # 实体类型枚举
```

### 2.2 修改现有模块

- **CombatSystem.ts**: 添加敌人碰撞检测、伤害计算
- **PlayerController.ts**: 添加生命值系统、受击处理
- **World.ts**: 添加方块变更追踪（用于增量存档）
- **Game.ts**: 集成敌人更新和存档系统

### 2.3 数据流

```
游戏主循环 (Game.update)
  ├─ AutoSave.update()           # 检查 30s 定时保存
  ├─ EnemySpawner.update()        # 检查区域刷新条件
  ├─ 所有 Enemy.update()          # AI 决策 + 移动动画
  ├─ CombatSystem.checkCollisions() # 攻击判定
  └─ PlayerController.update()     # 玩家状态更新
```

---

## 3. 敌人系统详细设计

### 3.1 敌人属性配置

| 敌人类型 | 生命值 | 伤害 | 移动速度 | 生成深度 | 掉落物 |
|---------|--------|------|-----------|-----------|--------|
| **史莱姆** | 15 HP | 3 | 2.5 m/s | Y < 25 | 粘液 x1-3 |
| **蝙蝠** | 25 HP | 6 | 4.0 m/s | Y > 10, 空洞 | 蝙蝠翅膀 x1-2 |
| **骷髅** | 40 HP | 10 | 1.8 m/s | Y < 15 | 骨头 x1 |

### 3.2 AI 行为设计

**SimpleAI（史莱姆）**
- 直线朝玩家移动
- 碰到方块时停止
- 简单但可能在复杂地形卡住

**FlyingAI（蝙蝠）**
- 直线朝玩家移动
- 忽略地形方块（可以穿过空气）
- 高度差容忍 ±5 格

**PathfindingAI（骷髅）**
- 使用射线检测避开直接障碍
- 简单的左右绕行逻辑
- 被卡住时尝试跳跃

### 3.3 刷新机制

**区域刷新规则**:
- 每 16x16x16 区块检查史莱姆（Y < 25）
- 每 20x20x20 区块检查蝙蝠（Y > 10，空气 > 50%）
- 每 32x32x32 区块检查骷髅（Y < 15）

**刷新条件**:
- 玩家进入新区域
- 区域内敌人数量 < 上限
- 距上次击杀 > 60 秒

**上限控制**:
- 史莱姆: 最多 3 只/区块
- 蝙蝠: 最多 2 只/区块
- 骷髅: 最多 1 只/区块

---

## 4. 存档系统详细设计

### 4.1 存档策略

**自动保存**: 每 30 秒触发一次
**手动保存**: F5 键 / ESC 菜单
**存档槽位**: 1 个自动存档 + 3 个手动存档

### 4.2 存档数据结构

```typescript
interface SaveData {
  version: string                    // 存档版本（兼容性）
  timestamp: number                  // 保存时间
  player: {
    position: { x: number, y: number, z: number }
    health: number                   // 生命值
    inventory: BlockType[]           // 快捷栏物品
  }
  modifiedBlocks: {                  // 已修改方块
    key: string                      // "x,y,z"
    type: BlockType
  }[]
  worldSeed?: string                // 未来支持随机种子
  enemies: EnemySaveData[]          // 敌人状态（可选）
}

interface EnemySaveData {
  type: string
  position: { x: number, y: number, z: number }
  health: number
  isDead: boolean
}
```

### 4.3 IndexedDB 结构

**数据库**: `UndergroundExplorerDB`
**对象存储**: `saves`
**索引**: `timestamp`

存储容量预估：
- 玩家数据: ~200 bytes
- 1000 个修改方块: ~24 KB
- 单个存档: ~25-50 KB
- 4 个存档槽: ~200 KB（远低于配额）

### 4.4 错误处理

**保存失败**:
- 降级到内存存储（临时方案）
- 显示警告提示

**加载失败**:
- 提示存档损坏
- 返回主菜单或新建游戏

**版本不兼容**:
- 尝试数据迁移
- 失败则提示重新开始

---

## 5. 实现优先级

### 阶段 1: 敌人基础（核心）
1. 实现 `Enemy.ts` 基类
2. 实现三种敌人类型
3. 实现 SimpleAI
4. 集成到游戏循环
5. 碰撞检测和伤害

### 阶段 2: 存档系统（核心）
1. 实现 `SaveManager.ts` 和 IndexedDB
2. 实现方块变更追踪
3. 自动保存定时器
4. 加载/保存 UI

### 阶段 3: AI 增强（扩展）
1. 实现 FlyingAI
2. 实现 PathfindingAI
3. 调优和平衡测试

### 阶段 4: 打磨（细节）
1. 掉落物拾取系统
2. 死亡动画和音效
3. UI 反馈（伤害数字、血条）

---

## 6. 技术风险与缓解

### 6.1 性能风险

**风险**: 大量敌人 + 碰撞检测导致帧率下降
**缓解**:
- 限制同时存在敌人数量上限（~50 只）
- 使用空间分区优化碰撞检测
- 简化 AI 计算频率（每 100ms 一次）

### 6.2 存档损坏

**风险**: 异常关闭导致存档损坏
**缓解**:
- 保存前验证数据完整性
- 保留备份存档（自动存档的副本）
- 使用事务确保原子写入

### 6.3 浏览器兼容性

**风险**: IndexedDB 在某些浏览器受限
**缓解**:
- 检测 IndexedDB 可用性
- 降级到 localStorage（功能受限）
- 明确最低浏览器要求

---

## 7. 测试计划

### 7.1 单元测试

- `Enemy` 类：生命值、伤害计算
- `SaveManager`：读写、数据验证
- AI 行为：边界条件测试

### 7.2 集成测试

- 敌人刷新和消失
- 存档加载后的状态恢复
- 战斗交互（玩家 vs 敌人）

### 7.3 性能测试

- 50 只敌人同时存在
- 1000 个修改方块的存档/加载
- 长时间游戏运行（内存泄漏检测）

---

## 8. 未来扩展

### 8.1 Boss 系统（Phase 4.5）
- 大型敌人模型
- 多阶段战斗模式
- 专属掉落和奖励

### 8.2 隐藏区域（Phase 4.5）
- 地牢生成
- 宝箱系统
- 稀有敌人

### 8.3 队友系统（Phase 5）
- 敌人仇恨系统优化
- 友好 NPC
- 队友装备和指令

---

**文档版本**: 1.0
**最后更新**: 2026-02-14
**下一步**: 创建实现计划 (superpowers:writing-plans)
